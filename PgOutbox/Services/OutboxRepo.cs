using Dapper;
using Newtonsoft.Json;
using Npgsql;
using PgOutbox.Contracts;

namespace PgOutbox.Services;

internal sealed class OutboxRepo<T> where T : new()
{
    private readonly PgOutboxSettings settings;
    private readonly string outboxTableName;
    private readonly string historyTableName;
    private readonly string insertCommand;
    private readonly string occupyByIdQuery;
    private readonly string occupyBatchQuery;
    private readonly string deleteCommand;
    private readonly string historyCommand;

    internal OutboxRepo(PgOutboxSettings settings)
    {
        this.settings = settings;
        outboxTableName = TableHelper.GetOutboxName<T>();
        historyTableName = TableHelper.GetHistoryName<T>();
        
        insertCommand = $"INSERT INTO {outboxTableName} (Data) VALUES (@Data) RETURNING Id, Created";
        
        occupyByIdQuery = $@"
UPDATE {outboxTableName}
SET OccupiedTill = current_timestamp + interval '{settings.OccupationTimeSeconds} second'
WHERE
	Id = @Id
	AND
	(OccupiedTill IS NULL OR OccupiedTill < current_timestamp)
RETURNING Id, Data, Created";
        
        occupyBatchQuery = @$"
WITH batch AS (
	SELECT Id, Data, Created
	FROM {outboxTableName}
	WHERE (OccupiedTill IS NULL OR OccupiedTill < current_timestamp)
    ORDER BY Created
	LIMIT 10
    FOR UPDATE SKIP LOCKED
)
UPDATE {outboxTableName} ob SET
	OccupiedTill = current_timestamp + interval '{settings.OccupationTimeSeconds} second'
FROM batch b WHERE b.Id = ob.Id
RETURNING b.Id, b.Data, b.Created";

        deleteCommand = $"DELETE FROM {outboxTableName} WHERE Id = ANY(@Ids)";
        historyCommand = @$"
INSERT INTO {historyTableName} (Data, Created)
    SELECT Data, Created FROM {outboxTableName} WHERE Id = ANY(@Ids)";
    }

    #region Init migration

    public async Task InitMigration()
    {
        await using var con = new NpgsqlConnection(settings.ConnectionString);
        await con.OpenAsync();
        
        var cmd = @$"
CREATE TABLE IF NOT EXISTS {outboxTableName} (
    Id INT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    Data TEXT NOT NULL,
    Created TIMESTAMP DEFAULT current_timestamp,
    OccupiedTill TIMESTAMP 
);

CREATE INDEX IF NOT EXISTS
    IDX_{outboxTableName}_Created_OccupiedTill
    ON {outboxTableName} (Created, OccupiedTill);";
        
        await con.ExecuteAsync(cmd);

        if (settings.UseHistoryTable)
        {
            cmd = @$"
CREATE TABLE IF NOT EXISTS {historyTableName} (
    Id INT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    Data TEXT NOT NULL,
    Created TIMESTAMP NOT NULL,
    Released TIMESTAMP DEFAULT current_timestamp                                                     
);";
            await con.ExecuteAsync(cmd);
        }
    }

    #endregion

    #region Insert

    public async Task<InsertResult> Insert(T entity, CancellationToken ct)
    {
        await using var con = new NpgsqlConnection(settings.ConnectionString);
        await con.OpenAsync(ct);
        var data = JsonConvert.SerializeObject(entity);
        return await con.QueryFirstAsync<InsertResult>(
            insertCommand,
            new { Data = data }
        );
    }

    public async Task<InsertResult> Insert(
        T entity,
        NpgsqlConnection connection,
        NpgsqlTransaction transaction
    )
    {
        var data = JsonConvert.SerializeObject(entity);
        return await connection.QueryFirstAsync<InsertResult>(
            insertCommand,
            new { Data = data },
            transaction
        );
    }

    #endregion

    public async Task<OccupyResult<T>?> Occupy(int id, CancellationToken ct)
    {
        await using var con = new NpgsqlConnection(settings.ConnectionString);
        await con.OpenAsync(ct);
        var record = await con.QueryFirstOrDefaultAsync<OccupyResultDto?>(
            occupyByIdQuery,
            new { Id = id }
        );
        return record != null
            ? new OccupyResult<T>
            {
                Id = record.Id,
                Created = record.Created,
                Entity = JsonConvert.DeserializeObject<T>(record.Data) ?? new T()
            }
            : null;
    }
    
    public async Task<List<OccupyResult<T>>> OccupyBatch(CancellationToken ct)
    {
        await using var con = new NpgsqlConnection(settings.ConnectionString);
        await con.OpenAsync(ct);
        var records = await con.QueryAsync<OccupyResultDto>(
            occupyBatchQuery,
            new { settings.BatchSize }
        );
        return records.Select(
            record => new OccupyResult<T>
            {
                Id = record.Id,
                Created = record.Created,
                Entity = JsonConvert.DeserializeObject<T>(record.Data) ?? new T()
            }
        ).ToList();
    }

    public async Task Release(IEnumerable<int> ids, CancellationToken ct)
    {
        if (!ids.Any())
            return;
        
        var param = new {Ids = ids.ToList()};
        
        await using var con = new NpgsqlConnection(settings.ConnectionString);
        await con.OpenAsync(ct);

        var transaction = settings.UseHistoryTable
            ? await con.BeginTransactionAsync(ct)
            : null;
        
        if (settings.UseHistoryTable)
                await con.ExecuteAsync(
                    historyCommand,
                    param,
                    transaction
                );

        await con.ExecuteAsync(
            deleteCommand,
            param,
            transaction
        );

        if (transaction != null)
            await transaction.CommitAsync(ct);
    }
}